;;;Autores: Arthur Procopio (34464) Fabricio do Carmo (35007) Felipe Amorim (34452)

(setq pilha nil);Pilha onde sera armazenado as coordenadas dos caminhos possiveis
(setq labirinto (make-array '(10 10)));Matriz do labirinto
(setq posicaox 1);Posicao atual do verificador no eixo X
(setq posicaoy 0);Posicao atual do verificados no eixo Y
(setq cont 0);Contador de passos

(setf (aref labirinto 0 0) 8);Atribuicao dos valores para criancao do labirinto
(setf (aref labirinto 0 1) 0);0 para caminho aberto, 1 para parede e 8 para caminho ja percorrido ou atual
(setf (aref labirinto 0 2) 1)
(setf (aref labirinto 0 3) 1)
(setf (aref labirinto 0 4) 1)
(setf (aref labirinto 0 5) 1)
(setf (aref labirinto 0 6) 1)
(setf (aref labirinto 0 7) 1)
(setf (aref labirinto 0 8) 1)
(setf (aref labirinto 0 9) 1)

(setf (aref labirinto 1 0) 1)
(setf (aref labirinto 1 1) 0)
(setf (aref labirinto 1 2) 1)
(setf (aref labirinto 1 3) 1)
(setf (aref labirinto 1 4) 0)
(setf (aref labirinto 1 5) 1)
(setf (aref labirinto 1 6) 1)
(setf (aref labirinto 1 7) 1)
(setf (aref labirinto 1 8) 1)
(setf (aref labirinto 1 9) 1)

(setf (aref labirinto 2 0) 1)
(setf (aref labirinto 2 1) 0)
(setf (aref labirinto 2 2) 1)
(setf (aref labirinto 2 3) 1)
(setf (aref labirinto 2 4) 0)
(setf (aref labirinto 2 5) 1)
(setf (aref labirinto 2 6) 0)
(setf (aref labirinto 2 7) 0)
(setf (aref labirinto 2 8) 0)
(setf (aref labirinto 2 9) 1)

(setf (aref labirinto 3 0) 1)
(setf (aref labirinto 3 1) 0)
(setf (aref labirinto 3 2) 0)
(setf (aref labirinto 3 3) 0)
(setf (aref labirinto 3 4) 0)
(setf (aref labirinto 3 5) 1)
(setf (aref labirinto 3 6) 0)
(setf (aref labirinto 3 7) 1)
(setf (aref labirinto 3 8) 0)
(setf (aref labirinto 3 9) 1)

(setf (aref labirinto 4 0) 1)
(setf (aref labirinto 4 1) 0)
(setf (aref labirinto 4 2) 1)
(setf (aref labirinto 4 3) 1)
(setf (aref labirinto 4 4) 1)
(setf (aref labirinto 4 5) 1)
(setf (aref labirinto 4 6) 0)
(setf (aref labirinto 4 7) 1)
(setf (aref labirinto 4 8) 0)
(setf (aref labirinto 4 9) 1)

(setf (aref labirinto 5 0) 1)
(setf (aref labirinto 5 1) 0)
(setf (aref labirinto 5 2) 1)
(setf (aref labirinto 5 3) 1)
(setf (aref labirinto 5 4) 0)
(setf (aref labirinto 5 5) 0)
(setf (aref labirinto 5 6) 0)
(setf (aref labirinto 5 7) 1)
(setf (aref labirinto 5 8) 0)
(setf (aref labirinto 5 9) 1)

(setf (aref labirinto 6 0) 1)
(setf (aref labirinto 6 1) 0)
(setf (aref labirinto 6 2) 0)
(setf (aref labirinto 6 3) 0)
(setf (aref labirinto 6 4) 0)
(setf (aref labirinto 6 5) 1)
(setf (aref labirinto 6 6) 0)
(setf (aref labirinto 6 7) 1)
(setf (aref labirinto 6 8) 0)
(setf (aref labirinto 6 9) 1)

(setf (aref labirinto 7 0) 1)
(setf (aref labirinto 7 1) 1)
(setf (aref labirinto 7 2) 1)
(setf (aref labirinto 7 3) 1)
(setf (aref labirinto 7 4) 1)
(setf (aref labirinto 7 5) 1)
(setf (aref labirinto 7 6) 0)
(setf (aref labirinto 7 7) 1)
(setf (aref labirinto 7 8) 0)
(setf (aref labirinto 7 9) 1)

(setf (aref labirinto 8 0) 1)
(setf (aref labirinto 8 1) 0)
(setf (aref labirinto 8 2) 0)
(setf (aref labirinto 8 3) 0)
(setf (aref labirinto 8 4) 0)
(setf (aref labirinto 8 5) 0)
(setf (aref labirinto 8 6) 0)
(setf (aref labirinto 8 7) 1)
(setf (aref labirinto 8 8) 0)
(setf (aref labirinto 8 9) 1)

(setf (aref labirinto 9 0) 1)
(setf (aref labirinto 9 1) 1)
(setf (aref labirinto 9 2) 1)
(setf (aref labirinto 9 3) 1)
(setf (aref labirinto 9 4) 1)
(setf (aref labirinto 9 5) 1)
(setf (aref labirinto 9 6) 1)
(setf (aref labirinto 9 7) 1)
(setf (aref labirinto 9 8) 0)
(setf (aref labirinto 9 9) 0)


(defun imprime();Imprime na tela o labirinto e coloca o numero 8 na posição atual de verificacao
	(dotimes (i 10)
		(dotimes (j 10)
			(if (and (= posicaox j)(= posicaoy i))
					(setf (aref labirinto i j) 8)
				)
			)
		)
	(dotimes (o 10)
		(dotimes (p 10)
		(write (aref labirinto o p)))
		(format t "~%")
		)
	(format t "~%")
)


(defun procura();Usando como referencia a posicao atual verifica os 4 lados posiveis de se mover e empilha todos os lados que nao sao paredes nem caminho ja percorrido
	(if (<= (+ 1 posicaox) 9)
	(if (= (aref labirinto posicaoy (+ 1 posicaox)) 0)
		(progn
			(push (+ 1 posicaox) pilha)
			(push posicaoy pilha)
		)))
	(if (> (- posicaox 1) 0)
	(if (= (aref labirinto posicaoy (- posicaox 1)) 0)
		(progn
			(push (- posicaox 1) pilha)
			(push posicaoy pilha)
		)))
	(if (<= (+ 1 posicaoy) 9)
	(if (= (aref labirinto (+ 1 posicaoy) posicaox) 0)
		(progn
			(push posicaox pilha)
			(push (+ 1 posicaoy) pilha)
		)))
	(if (> (- posicaoy 1) 0)
	(if (= (aref labirinto (- posicaoy 1) posicaox) 0)
		(progn
			(push posicaox pilha)
			(push (- posicaoy 1) pilha)
		)))
	(setf posicaoy (pop pilha));Desempilha o ultimo lado empilhado e adota ele como o proximo passo
	(setf posicaox (pop pilha))
	(imprime);Chama a funcao para imprimir com o proximo passo ja atingido
)

(imprime)
(loop ;Depois de alguns problemas com a recurcao resolvemos criar um laco que chama a funcao de procura enquanto a ultima posicao da matriz nao for preenchida
(setf cont (+ cont 1));Acrescenta mais 1 ao contador de passos
(write cont)
(format t "~%")
(procura)
(when (and (= posicaox 9) (= posicaoy 9))
(return)))
